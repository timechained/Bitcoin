<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>₿ Bitcoin</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;700&family=Outfit:wght@200;300;400;600;700;800&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-deep: #0a0a0f;
            --bg-card: #12121a;
            --bg-card-hover: #1a1a26;
            --border: #1e1e2e;
            --border-glow: #f7931a30;
            --text-primary: #e8e6e3;
            --text-secondary: #7a7a8c;
            --text-muted: #4a4a5c;
            --bitcoin: #f7931a;
            --bitcoin-glow: #f7931a40;
            --bitcoin-dim: #f7931a20;
            --green: #00d4aa;
            --red: #ff4757;
            --purple: #a78bfa;
            --blue: #60a5fa;
            --cyan: #22d3ee;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: var(--bg-deep);
            color: var(--text-primary);
            font-family: 'Outfit', sans-serif;
            min-height: 100vh;
            overflow-x: hidden;
        }
        body::before {
            content: '';
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background-image: 
                linear-gradient(var(--border) 1px, transparent 1px),
                linear-gradient(90deg, var(--border) 1px, transparent 1px);
            background-size: 60px 60px;
            opacity: 0.15;
            pointer-events: none;
            z-index: 0;
        }
        .ambient-glow {
            position: fixed;
            top: -200px; right: -200px;
            width: 600px; height: 600px;
            background: radial-gradient(circle, var(--bitcoin-dim) 0%, transparent 70%);
            pointer-events: none; z-index: 0;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
            z-index: 1;
        }
        header {
            padding: 40px 0 30px;
            border-bottom: 1px solid var(--border);
            margin-bottom: 30px;
        }
        .header-top {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            flex-wrap: wrap;
            gap: 20px;
        }
        .logo { display: flex; align-items: center; gap: 14px; }
        .logo-icon {
            width: 48px; height: 48px;
            border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            box-shadow: 0 0 30px var(--bitcoin-glow);
        }
        .logo-text h1 {
            font-size: 22px; font-weight: 700; letter-spacing: -0.5px;
            background: linear-gradient(135deg, var(--text-primary), var(--bitcoin));
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
        }
        .logo-text span {
            font-size: 12px; color: var(--text-muted);
            font-family: 'JetBrains Mono', monospace;
            letter-spacing: 2px; text-transform: uppercase;
        }
        .live-price { text-align: right; }
        .live-price .price {
            font-size: 32px; font-weight: 800;
            font-family: 'JetBrains Mono', monospace; letter-spacing: -1px;
            transition: color 0.3s ease;
        }
        .live-price .change {
            font-size: 13px; font-family: 'JetBrains Mono', monospace; margin-top: 2px;
        }
        .live-price .meta {
            font-size: 11px; color: var(--text-muted); margin-top: 4px;
            font-family: 'JetBrains Mono', monospace;
        }
        .positive { color: var(--green); }
        .negative { color: var(--red); }
        .stats-bar {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 12px; margin-bottom: 30px;
        }
        .stat-card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 16px 18px;
            transition: all 0.3s ease;
        }
        .stat-card:hover {
            border-color: var(--border-glow);
            background: var(--bg-card-hover);
            transform: translateY(-2px);
        }
        .stat-card .label {
            font-size: 11px; color: var(--text-muted);
            text-transform: uppercase; letter-spacing: 1.5px;
            font-family: 'JetBrains Mono', monospace; margin-bottom: 6px;
        }
        .stat-card .value {
            font-size: 20px; font-weight: 700;
            font-family: 'JetBrains Mono', monospace; letter-spacing: -0.5px;
        }
        .stat-card .sub { font-size: 11px; color: var(--text-secondary); margin-top: 3px; }
        .chart-section {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 24px; margin-bottom: 24px;
        }
        .chart-header {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 16px; flex-wrap: wrap; gap: 12px;
        }
        .chart-title {
            font-size: 16px; font-weight: 600;
            display: flex; align-items: center; gap: 10px;
        }
        .chart-title .dot {
            width: 8px; height: 8px; border-radius: 50%;
            background: var(--bitcoin);
            box-shadow: 0 0 10px var(--bitcoin-glow);
        }
        .chart-description {
            font-size: 13px; color: var(--text-secondary);
            max-width: 700px; line-height: 1.5; margin-bottom: 4px;
        }
        .tab-nav {
            display: flex; gap: 4px;
            background: var(--bg-deep); padding: 4px; border-radius: 10px;
            width: fit-content;
        }
        .tab-btn {
            padding: 7px 16px; border: none; background: transparent;
            color: var(--text-secondary);
            font-family: 'JetBrains Mono', monospace; font-size: 12px;
            border-radius: 7px; cursor: pointer; transition: all 0.2s;
        }
        .tab-btn.active { background: var(--bitcoin); color: var(--bg-deep); font-weight: 600; }
        .tab-btn:hover:not(.active) { color: var(--text-primary); background: var(--bg-card-hover); }
        .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 24px; }
        footer {
            text-align: center; padding: 40px 0;
            color: var(--text-muted); font-size: 12px;
            font-family: 'JetBrains Mono', monospace;
            border-top: 1px solid var(--border); margin-top: 40px;
        }
        .cycle-table {
            width: 100%; border-collapse: collapse;
            font-family: 'JetBrains Mono', monospace; font-size: 13px;
        }
        .cycle-table th {
            text-align: left; color: var(--text-muted); font-weight: 400;
            font-size: 11px; text-transform: uppercase; letter-spacing: 1px;
            padding: 10px 12px; border-bottom: 1px solid var(--border);
        }
        .cycle-table td { padding: 12px; border-bottom: 1px solid var(--border); }
        .cycle-table tr:last-child td { border-bottom: none; }
        .cycle-table tr:hover td { background: var(--bg-card-hover); }
        .badge {
            display: inline-block; padding: 3px 8px;
            border-radius: 6px; font-size: 11px; font-weight: 600;
        }
        .badge-active { background: var(--bitcoin-dim); color: var(--bitcoin); }
        .badge-past { background: #1e1e2e; color: var(--text-secondary); }
        @media (max-width: 768px) {
            .container { padding: 12px; }
            header { padding: 20px 0; }
            .live-price .price { font-size: 24px; }
            .logo-text h1 { font-size: 18px; }
            .grid-2 { grid-template-columns: 1fr; }
            .stats-bar { grid-template-columns: repeat(2, 1fr); }
            .chart-section { padding: 16px; }
        }
        @media (max-width: 480px) {
            .stats-bar { grid-template-columns: 1fr; }
            .header-top { flex-direction: column; }
            .live-price { text-align: left; }
        }
        #chart-pl-canvas {
            border-radius: 8px;
            user-select: none;
            -webkit-user-select: none;
        }
        .js-plotly-plot .plotly .modebar { top: 8px !important; right: 8px !important; }
        .js-plotly-plot .plotly .modebar-btn { color: var(--text-muted) !important; }
        .js-plotly-plot .plotly .modebar-btn:hover { color: var(--bitcoin) !important; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.4; } }
        .live-pulse { animation: pulse 1.5s ease-in-out infinite; }
    </style>
</head>
<body>
<div class="ambient-glow"></div>
<div class="container">
    <header>
        <div class="header-top">
            <div class="logo">
                <div class="logo-icon"><svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 64 64"><circle cx="32" cy="32" r="32" fill="#f7931a"/><path fill="#fff" d="M45.2 28.1c.6-4.2-2.6-6.5-7-8l1.4-5.7-3.5-.9-1.4 5.5c-.9-.2-1.9-.4-2.8-.7l1.4-5.5-3.5-.9-1.4 5.7c-.8-.2-1.5-.3-2.2-.5l0 0-4.8-1.2-.9 3.7s2.6.6 2.5.6c1.4.4 1.7 1.3 1.6 2l-1.6 6.5c.1 0 .2.1.3.1l-.3-.1-2.3 9.1c-.2.4-.6 1.1-1.6.8 0 0-2.5-.6-2.5-.6l-1.7 4 4.5 1.1c.8.2 1.7.4 2.5.7l-1.4 5.8 3.5.9 1.4-5.7c1 .3 1.9.5 2.8.7l-1.4 5.7 3.5.9 1.4-5.8c6 1.1 10.5.7 12.4-4.7 1.5-4.4-.1-6.9-3.2-8.5 2.3-.5 4-2.1 4.5-5.2zm-8 11.2c-1.1 4.4-8.5 2-10.9 1.4l1.9-7.8c2.4.6 10.1 1.8 9 6.4zm1.1-11.3c-1 4-7.1 2-9.1 1.5l1.8-7.1c2 .5 8.4 1.4 7.3 5.6z"/></svg></div>
                <div class="logo-text">
                    <h1>Bitcoin</h1>
                    <span>Money in Cyberspace</span>
                </div>
            </div>
            <div class="live-price">
                <div style="display:flex;align-items:center;justify-content:flex-end;gap:8px">
                    <span id="live-dot" style="width:8px;height:8px;border-radius:50%;background:#4a4a5c;display:inline-block;"></span>
                    <div class="price" id="live-price">–</div>
                </div>
                <div class="change" id="live-change"></div>
                <div class="meta" id="live-meta">Lade...</div>
            </div>
        </div>
    </header>
    <div class="chart-section">
        <div class="chart-header">
            <div>
                <div class="chart-title"><span class="dot"></span> Bitcoin Preis</div>
                <div class="chart-description">
                    BTC/USD Tageskurs seit den ersten Handelstagen.
                </div>
            </div>
            <div style="display:flex;flex-direction:column;gap:6px;align-items:flex-end">
                <div class="tab-nav">
                    <button class="tab-btn active" onclick="setPLScale('log')">Log</button>
                    <button class="tab-btn" onclick="setPLScale('linear')">Linear</button>
                </div>
                <div class="tab-nav">
                    <button class="tab-btn zoom-btn" data-zoom="min" onclick="setZoom('min')">Min</button>
                    <button class="tab-btn zoom-btn" data-zoom="std" onclick="setZoom('std')">Standard</button>
                    <button class="tab-btn zoom-btn active" data-zoom="max" onclick="setZoom('max')">Max</button>
                </div>
            </div>
        </div>
        <canvas id="chart-pl-canvas" style="width:100%;height:500px;display:block"></canvas>
    </div>

    <div class="stats-bar">
        <div class="stat-card">
            <div class="label">Tage seit Halving</div>
            <div class="value" id="stat-days">–</div>
            <div class="sub" id="stat-halving-date">–</div>
        </div>
        <div class="stat-card">
            <div class="label">Wochen seit Halving</div>
            <div class="value" id="stat-weeks">–</div>
            <div class="sub">Aktueller Zyklus #5</div>
        </div>
        <div class="stat-card">
            <div class="label">Power Law Boden</div>
            <div class="value" id="stat-pl-floor">–</div>
            <div class="sub" id="stat-pl-dist">–</div>
        </div>
        <div class="stat-card">
            <div class="label">ATH / Power-Law</div>
            <div class="value" id="stat-ath-ratio">–</div>
            <div class="sub" id="stat-ath-info">–</div>
        </div>
        <div class="stat-card">
            <div class="label">Drawdown vom ATH</div>
            <div class="value negative" id="stat-drawdown">–</div>
            <div class="sub" id="stat-ath-date">–</div>
        </div>
        <div class="stat-card">
            <div class="label">Zyklusposition</div>
            <div class="value" id="stat-position">–</div>
            <div class="sub">Historischer Vergleich</div>
        </div>
    </div>

    <div class="grid-2">
        <div class="chart-section">
            <div class="chart-title" style="margin-bottom:8px"><span class="dot" style="background:var(--cyan)"></span> Zyklusvergleich (normalisiert)</div>
            <div class="chart-description">Alle Zyklen überlagert – Tag 0 = Halving. X-Achse = Tage, Y-Achse = Preis ÷ Halving-Preis.</div>
            <div id="chart-cycles" style="width:100%;height:380px"></div>
        </div>
        <div class="chart-section">
            <div class="chart-title" style="margin-bottom:8px"><span class="dot" style="background:var(--purple)"></span> ATH / Power-Law Ratio</div>
            <div class="chart-description">Wie weit über dem Power Law lag das ATH? Sinkender Trend = zunehmende Marktreife.</div>
            <div id="chart-ath" style="width:100%;height:380px"></div>
        </div>
    </div>

    <div class="chart-section">
        <div class="chart-title" style="margin-bottom:16px"><span class="dot" style="background:var(--green)"></span> Zyklusvergleich – Kennzahlen</div>
        <div style="overflow-x:auto">
            <table class="cycle-table">
                <thead><tr>
                    <th>Zyklus</th><th>Halving</th><th>ATH Datum</th><th>Wochen→ATH</th>
                    <th>ATH Preis</th><th>Max Drawdown</th><th>ATH/PL</th><th>Status</th>
                </tr></thead>
                <tbody id="tbl"></tbody>
            </table>
        </div>
    </div>

    <footer>
        Datenquelle: Blockchain.info Tageskurse (ab 2010, automatisch aktuell)<br>
        Power-Law-Modell: log₁₀(price) = a · log₁₀(days_since_genesis) + b<br><br>
        <span style="color:var(--text-secondary)">⚠ Statistisches Modell auf Basis von 4 Zyklen – keine Anlageberatung.</span>
    </footer>
</div>

<script>
// === CONFIG ===
const GENESIS = new Date('2009-01-03');
const GENESIS_MS = GENESIS.getTime();
const DAY_MS = 86400000;

const HALVINGS = [
    { date: new Date('2012-11-28'), label: 'Halving #1' },
    { date: new Date('2016-07-09'), label: 'Halving #2' },
    { date: new Date('2020-05-11'), label: 'Halving #3' },
    { date: new Date('2024-04-19'), label: 'Halving #4' },
];

const CYCLE_ATHS = [
    { price: 1163, date: new Date('2013-11-29'), drawdown: -87 },
    { price: 19783, date: new Date('2017-12-17'), drawdown: -84 },
    { price: 69000, date: new Date('2021-11-10'), drawdown: -77 },
    { price: 126200, date: new Date('2025-10-06'), drawdown: -43 },
];

const COLORS = ['#60a5fa', '#a78bfa', '#00d4aa', '#f7931a'];
const CLABELS = ['Zyklus 1 (2012→)', 'Zyklus 2 (2016→)', 'Zyklus 3 (2020→)', 'Zyklus 4 (2024→)'];

// Power Law fit: log10(price) = a * log10(days) + b
function fitPowerLaw(data) {
    const pts = data.filter(d => d.price > 0 && d.days > 1);
    let sx=0, sy=0, sxy=0, sx2=0, n=pts.length;
    for (const d of pts) {
        const x = Math.log10(d.days), y = Math.log10(d.price);
        sx+=x; sy+=y; sxy+=x*y; sx2+=x*x;
    }
    const a = (n*sxy - sx*sy) / (n*sx2 - sx*sx);
    const b = (sy - a*sx) / n;
    let sr2 = 0;
    for (const d of pts) {
        const pred = a * Math.log10(d.days) + b;
        sr2 += (Math.log10(d.price) - pred) ** 2;
    }
    return { a, b, std: Math.sqrt(sr2 / (n-2)) };
}

function plPrice(days, a, b) {
    return Math.pow(10, a * Math.log10(days) + b);
}

// Floor fit: OLS on the 5th-percentile residual points (furthest below PL)
function fitFloor(data, pl) {
    const pts = data.filter(d => d.price > 0 && d.days > 1);
    const residuals = pts.map(d => {
        const logP = Math.log10(d.price);
        const pred = pl.a * Math.log10(d.days) + pl.b;
        return { d, r: logP - pred };
    });
    residuals.sort((a, b) => a.r - b.r);
    const cutoff = Math.ceil(residuals.length * 0.02);
    const bottom = residuals.slice(0, cutoff).map(e => e.d);
    // OLS on selected floor points
    let sx=0, sy=0, sxy=0, sx2=0, n=bottom.length;
    for (const d of bottom) {
        const x = Math.log10(d.days), y = Math.log10(d.price);
        sx+=x; sy+=y; sxy+=x*y; sx2+=x*x;
    }
    const a = (n*sxy - sx*sy) / (n*sx2 - sx*sx);
    const b = (sy - a*sx) / n;
    return { a, b };
}

// === PLOTLY DEFAULTS ===
const DL = {
    paper_bgcolor: 'rgba(0,0,0,0)', plot_bgcolor: 'rgba(0,0,0,0)',
    font: { family: 'JetBrains Mono, monospace', color: '#7a7a8c', size: 11 },
    margin: { l: 60, r: 20, t: 10, b: 50 },
    xaxis: { gridcolor: '#1e1e2e', zerolinecolor: '#1e1e2e', tickfont: { size: 10 } },
    yaxis: { gridcolor: '#1e1e2e', zerolinecolor: '#1e1e2e', tickfont: { size: 10 } },
    legend: { bgcolor: 'rgba(0,0,0,0)', font: { size: 10 }, orientation: 'h', y: -0.18 },
    hovermode: 'x unified',
    hoverlabel: { bgcolor: '#1a1a26', bordercolor: '#2e2e3e', font: { family: 'JetBrains Mono', size: 11, color: '#e8e6e3' } },
};
const PC = { responsive: true, displaylogo: false, modeBarButtonsToRemove: ['select2d','lasso2d','autoScale2d'] };

// === RENDER ===
let plScale = 'log';
let plZoom = 'max';
let DATA, PL, FLOOR;

let plAnimId = null;

function renderPL(animate) {
    if (plAnimId) { cancelAnimationFrame(plAnimId); plAnimId = null; }

    const canvas = document.getElementById('chart-pl-canvas');
    const container = canvas.parentElement;
    const dpr = window.devicePixelRatio || 1;
    const w = container.clientWidth;
    const h = 500;
    canvas.width = w * dpr;
    canvas.height = h * dpr;
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';

    const ml = 70, mr = 20, mt = 16, mb = 44;
    const cw = w - ml - mr, ch = h - mt - mb;

    const validData = DATA.filter(d => d.price > 0);
    const isLog = plScale === 'log';

    // View bounds based on zoom
    let viewMin, viewMax;
    if (plZoom === 'min') {
        viewMin = Date.now() - 730 * DAY_MS;
        viewMax = Date.now() + 182 * DAY_MS;
    } else if (plZoom === 'std') {
        viewMin = validData[0].date.getTime();
        viewMax = Date.now() + 365 * DAY_MS;
    } else {
        viewMin = validData[0].date.getTime();
        const daysTo1M = Math.pow(10, (6 - PL.b) / PL.a);
        viewMax = GENESIS_MS + daysTo1M * DAY_MS + 365 * DAY_MS;
    }

    // How far the PL/Floor lines project into the future
    let lineMax;
    if (plZoom === 'min') lineMax = viewMax - 30 * DAY_MS;
    else if (plZoom === 'std') lineMax = viewMax - 90 * DAY_MS;
    else lineMax = viewMax - 182 * DAY_MS;

    function xPos(ms) { return ml + (ms - viewMin) / (viewMax - viewMin) * cw; }

    // Compute line data up to lineMax
    function lineData(a, b) {
        const pts = [];
        const daysMin = Math.max(1, (viewMin - GENESIS_MS) / DAY_MS);
        const daysMax = (lineMax - GENESIS_MS) / DAY_MS;
        const steps = 400;
        for (let i = 0; i <= steps; i++) {
            const logD = Math.log10(daysMin) + (Math.log10(daysMax) - Math.log10(daysMin)) * i / steps;
            const price = Math.pow(10, a * logD + b);
            const ms = GENESIS_MS + Math.pow(10, logD) * DAY_MS;
            pts.push({ x: xPos(ms), price });
        }
        return pts;
    }

    const plPts = PL ? lineData(PL.a, PL.b) : [];
    const flPts = FLOOR ? lineData(FLOOR.a, FLOOR.b) : [];

    // Visible price data
    const visData = validData.filter(d => {
        const ms = d.date.getTime();
        return ms >= viewMin && ms <= viewMax;
    });

    // Y bounds from all visible elements
    const allP = [
        ...visData.map(d => d.price),
        ...plPts.map(p => p.price),
        ...flPts.map(p => p.price),
    ].filter(p => p > 0);

    let minP, maxP;
    if (isLog) {
        let lo = Infinity, hi = -Infinity;
        for (const p of allP) { if (p < lo) lo = p; if (p > hi) hi = p; }
        minP = Math.log10(Math.max(0.01, lo));
        maxP = Math.log10(hi);
        const pad = (maxP - minP) * 0.06;
        minP -= pad; maxP += pad;
    } else {
        minP = 0;
        let hi = 0;
        for (const p of allP) { if (p > hi) hi = p; }
        maxP = hi * 1.08;
    }

    function yPos(price) {
        const v = isLog ? Math.log10(Math.max(0.01, price)) : price;
        return mt + ch - (v - minP) / (maxP - minP) * ch;
    }

    // Pixel points for price data
    const points = visData.map(d => ({
        x: xPos(d.date.getTime()),
        y: yPos(d.price)
    })).filter(p => p.y >= mt && p.y <= mt + ch);

    // Pixel points for lines
    const plPixels = plPts.map(p => ({ x: p.x, y: yPos(p.price) }));
    const flPixels = flPts.map(p => ({ x: p.x, y: yPos(p.price) }));

    // Tick label formatter
    function fmtTick(v) {
        if (v >= 1e6) { const m = v / 1e6; return '$' + (m % 1 === 0 ? m.toFixed(0) : m.toFixed(1)) + 'M'; }
        if (v >= 1000) { const k = v / 1000; return '$' + (k % 1 === 0 ? k.toFixed(0) : k.toFixed(0)) + 'k'; }
        if (v >= 1) return '$' + Math.round(v);
        return '$' + v;
    }

    function drawFrame(progress) {
        const ctx = canvas.getContext('2d');
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.clearRect(0, 0, w, h);

        // Grid - Y axis
        ctx.strokeStyle = '#1e1e2e';
        ctx.lineWidth = 1;
        ctx.font = '10px JetBrains Mono, monospace';
        ctx.fillStyle = '#7a7a8c';
        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';

        if (isLog) {
            const range = maxP - minP;
            const multiples = range < 1 ? [1, 1.5, 2, 3, 5, 7]
                            : range < 2.5 ? [1, 2, 3, 5, 7]
                            : [1, 2, 5];
            for (let exp = -2; exp <= 7; exp++) {
                for (const m of multiples) {
                    const tick = m * Math.pow(10, exp);
                    const lt = Math.log10(tick);
                    if (lt < minP || lt > maxP) continue;
                    const y = yPos(tick);
                    ctx.beginPath(); ctx.moveTo(ml, y); ctx.lineTo(ml + cw, y); ctx.stroke();
                    ctx.fillText(fmtTick(tick), ml - 8, y);
                }
            }
        } else {
            const step = Math.pow(10, Math.floor(Math.log10(maxP))) / 2;
            for (let tick = 0; tick <= maxP; tick += step) {
                const y = yPos(tick);
                if (y < mt || y > mt + ch) continue;
                ctx.beginPath(); ctx.moveTo(ml, y); ctx.lineTo(ml + cw, y); ctx.stroke();
                ctx.fillText(fmtTick(tick), ml - 8, y);
            }
        }

        // Grid - X axis
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';

        if (plZoom === 'min') {
            const d = new Date(viewMin);
            d.setDate(1);
            d.setMonth(d.getMonth() + 1);
            while (d.getTime() <= viewMax) {
                const x = xPos(d.getTime());
                if (x >= ml && x <= ml + cw) {
                    ctx.beginPath(); ctx.moveTo(x, mt); ctx.lineTo(x, mt + ch); ctx.stroke();
                    ctx.fillText(d.toLocaleDateString('de-DE', {month:'short', year:'2-digit'}), x, mt + ch + 8);
                }
                d.setMonth(d.getMonth() + 2);
            }
        } else {
            const startYear = new Date(viewMin).getFullYear();
            const endYear = new Date(viewMax).getFullYear();
            const step = (endYear - startYear) > 20 ? 5 : 2;
            for (let yr = Math.ceil((startYear + 1) / step) * step; yr <= endYear; yr += step) {
                const d = new Date(yr, 0, 1);
                const x = xPos(d.getTime());
                if (x >= ml && x <= ml + cw) {
                    ctx.beginPath(); ctx.moveTo(x, mt); ctx.lineTo(x, mt + ch); ctx.stroke();
                    ctx.fillText(yr.toString(), x, mt + ch + 8);
                }
            }
        }

        // Axis lines
        ctx.strokeStyle = '#2e2e3e';
        ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(ml, mt); ctx.lineTo(ml, mt + ch); ctx.lineTo(ml + cw, mt + ch); ctx.stroke();

        // Y-axis label
        ctx.save();
        ctx.fillStyle = '#7a7a8c';
        ctx.font = '11px JetBrains Mono, monospace';
        ctx.textAlign = 'center';
        ctx.translate(14, mt + ch / 2);
        ctx.rotate(-Math.PI / 2);
        ctx.fillText('USD', 0, 0);
        ctx.restore();

        // Clipping region
        ctx.save();
        ctx.beginPath();
        ctx.rect(ml, mt, cw, ch);
        ctx.clip();

        // === Power Law line (full projection, always visible) ===
        if (plPixels.length > 1) {
            ctx.beginPath();
            ctx.setLineDash([10, 7]);
            ctx.moveTo(plPixels[0].x, plPixels[0].y);
            for (let i = 1; i < plPixels.length; i++) ctx.lineTo(plPixels[i].x, plPixels[i].y);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.45)';
            ctx.lineWidth = 1.5;
            ctx.stroke();
            ctx.setLineDash([]);
        }

        // === Floor line (full projection, always visible, with glow) ===
        if (flPixels.length > 1) {
            const floorGlow = [
                { width: 12, alpha: 0.03 },
                { width: 8,  alpha: 0.05 },
                { width: 4,  alpha: 0.08 },
            ];
            for (const gl of floorGlow) {
                ctx.beginPath();
                ctx.moveTo(flPixels[0].x, flPixels[0].y);
                for (let i = 1; i < flPixels.length; i++) ctx.lineTo(flPixels[i].x, flPixels[i].y);
                ctx.strokeStyle = `rgba(255, 255, 255, ${gl.alpha})`;
                ctx.lineWidth = gl.width;
                ctx.lineJoin = 'round';
                ctx.lineCap = 'round';
                ctx.stroke();
            }
            ctx.beginPath();
            ctx.moveTo(flPixels[0].x, flPixels[0].y);
            for (let i = 1; i < flPixels.length; i++) ctx.lineTo(flPixels[i].x, flPixels[i].y);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.lineWidth = 1.5;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            ctx.stroke();
        }

        // === Price line (animated) ===
        const count = Math.floor(points.length * progress);
        if (count >= 2) {
            const glowLayers = [
                { width: 12, alpha: 0.03 },
                { width: 8,  alpha: 0.05 },
                { width: 4,  alpha: 0.08 },
            ];
            for (const gl of glowLayers) {
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                for (let i = 1; i < count; i++) ctx.lineTo(points[i].x, points[i].y);
                ctx.strokeStyle = `rgba(247, 147, 26, ${gl.alpha})`;
                ctx.lineWidth = gl.width;
                ctx.lineJoin = 'round';
                ctx.lineCap = 'round';
                ctx.stroke();
            }

            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < count; i++) ctx.lineTo(points[i].x, points[i].y);
            ctx.strokeStyle = '#f7931a';
            ctx.lineWidth = 1.5;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            ctx.stroke();

            if (progress < 1 && count > 0) {
                const tip = points[count - 1];
                ctx.save();
                ctx.shadowColor = 'rgba(247, 147, 26, 0.6)';
                ctx.shadowBlur = 30;
                ctx.fillStyle = 'rgba(255, 220, 160, 0.35)';
                ctx.beginPath();
                ctx.arc(tip.x, tip.y, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
                const grd = ctx.createRadialGradient(tip.x, tip.y, 0, tip.x, tip.y, 16);
                grd.addColorStop(0, 'rgba(255, 255, 255, 0.95)');
                grd.addColorStop(0.3, 'rgba(255, 230, 180, 0.5)');
                grd.addColorStop(0.7, 'rgba(247, 147, 26, 0.1)');
                grd.addColorStop(1, 'rgba(247, 147, 26, 0)');
                ctx.fillStyle = grd;
                ctx.beginPath();
                ctx.arc(tip.x, tip.y, 16, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(tip.x, tip.y, 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        ctx.restore();
    }

    if (animate !== false) {
        const duration = plZoom === 'min' ? 1000 : 2200;
        const start = performance.now();
        function tick(now) {
            const elapsed = now - start;
            let t = Math.min(elapsed / duration, 1);
            t = 1 - Math.pow(1 - t, 3);
            drawFrame(t);
            if (t < 1) plAnimId = requestAnimationFrame(tick);
        }
        plAnimId = requestAnimationFrame(tick);
    } else {
        drawFrame(1);
    }
}

function setPLScale(s) {
    plScale = s;
    document.querySelectorAll('.tab-btn:not(.zoom-btn)').forEach(b =>
        b.classList.toggle('active', b.textContent.toLowerCase() === s));
    renderPL();
}

function setZoom(z) {
    plZoom = z;
    document.querySelectorAll('.zoom-btn').forEach(b =>
        b.classList.toggle('active', b.dataset.zoom === z));
    renderPL();
}

function renderCycles() {
    const traces = [];
    for (let i = 0; i < HALVINGS.length; i++) {
        const hDate = HALVINGS[i].date;
        const nextH = HALVINGS[i+1]?.date || new Date('2028-04-01');
        const hEntry = DATA.find(d => d.date >= hDate);
        if (!hEntry) continue;
        const hPrice = hEntry.price;
        const cycle = DATA.filter(d => d.date >= hDate && d.date < nextH);
        traces.push({
            x: cycle.map(d => (d.date - hDate) / DAY_MS),
            y: cycle.map(d => d.price / hPrice),
            mode: 'lines', name: CLABELS[i],
            line: { color: COLORS[i], width: i===3 ? 2.5 : 1.5 },
            opacity: i===3 ? 1 : 0.6,
        });
    }
    Plotly.newPlot('chart-cycles', traces, {
        ...DL, height: 380,
        xaxis: { ...DL.xaxis, title:{text:'Tage seit Halving', font:{size:11}} },
        yaxis: { ...DL.yaxis, type:'log', title:{text:'Normalisiert', font:{size:11}} },
    }, PC);
}

function renderATHChart() {
    const {a, b} = PL;
    const ratios = CYCLE_ATHS.map(ath => {
        const days = (ath.date - GENESIS) / DAY_MS;
        return ath.price / plPrice(days, a, b);
    });
    const labels = ['Zyklus 1<br>2013','Zyklus 2<br>2017','Zyklus 3<br>2021','Zyklus 4<br>2025'];

    // Trend line
    const n=4; let sx=0,sy=0,sxy=0,sx2=0;
    for (let i=0;i<n;i++){sx+=i;sy+=ratios[i];sxy+=i*ratios[i];sx2+=i*i;}
    const ta=(n*sxy-sx*sy)/(n*sx2-sx*sx), tb=(sy-ta*sx)/n;

    Plotly.newPlot('chart-ath', [
        {
            x: labels, y: ratios, type: 'bar',
            marker: { color: COLORS, opacity: 0.85 },
            text: ratios.map(r=>r.toFixed(1)+'x'), textposition:'outside',
            textfont: { family:'JetBrains Mono', size:13, color:'#e8e6e3' },
            hovertemplate: '%{x}: %{y:.1f}x<extra></extra>',
        },
        {
            x: labels, y: [0,1,2,3].map(x=>ta*x+tb),
            mode: 'lines', name: 'Konvergenz-Trend',
            line: { color: '#ff475780', width: 2, dash: 'dash' },
        },
    ], {
        ...DL, height: 380, showlegend: true,
        yaxis: { ...DL.yaxis, title:{text:'ATH / Power-Law', font:{size:11}} },
    }, PC);
}

function updateStats() {
    const {a, b, std} = PL;
    const last = DATA[DATA.length-1];
    const price = lastLivePrice || last.price;
    const todayDays = Math.round((Date.now() - GENESIS_MS) / DAY_MS);
    const floor = plPrice(todayDays, FLOOR.a, FLOOR.b);
    const median = plPrice(todayDays, a, b);

    const lastH = HALVINGS[3];
    const daysH = Math.floor((Date.now() - lastH.date) / DAY_MS);
    const weeksH = Math.floor(daysH / 7);
    const ath = CYCLE_ATHS[3];
    const drawdown = ((price - ath.price) / ath.price * 100);
    const athDays = (ath.date - GENESIS) / DAY_MS;
    const athPL = plPrice(athDays, a, b);
    const athRatio = ath.price / athPL;

    const prev = DATA[DATA.length - 2];
    const dayChg = prev ? ((price - prev.price) / prev.price * 100) : 0;

    if (!lastLivePrice) {
        document.getElementById('live-price').textContent = '–';
        document.getElementById('live-change').textContent = '';
        document.getElementById('live-meta').textContent = 'Lade Live-Preis...';
    } else {
        document.getElementById('live-meta').textContent = last.date.toLocaleDateString('de-DE') + ' · Live';
    }

    document.getElementById('stat-days').textContent = daysH;
    document.getElementById('stat-halving-date').textContent = 'Halving: 19.04.2024';
    document.getElementById('stat-weeks').textContent = weeksH;
    document.getElementById('stat-pl-floor').textContent = '$' + floor.toLocaleString('en-US',{maximumFractionDigits:0});
    document.getElementById('stat-pl-dist').textContent = ((price-floor)/floor*100).toFixed(0) + '% über Boden';
    document.getElementById('stat-ath-ratio').textContent = athRatio.toFixed(1) + 'x';
    document.getElementById('stat-ath-info').textContent = 'ATH $126.200 / PL $' + athPL.toLocaleString('en-US',{maximumFractionDigits:0});
    document.getElementById('stat-drawdown').textContent = drawdown.toFixed(1) + '%';
    document.getElementById('stat-ath-date').textContent = 'ATH: 06.10.2025';
    const pos = document.getElementById('stat-position');
    if (weeksH > 75) { pos.textContent = 'Post-Top'; pos.style.color = 'var(--red)'; }
    else { pos.textContent = 'Pre-Top'; pos.style.color = 'var(--green)'; }
}

function renderTable() {
    const {a, b} = PL;
    document.getElementById('tbl').innerHTML = CYCLE_ATHS.map((ath, i) => {
        const h = HALVINGS[i];
        const wks = Math.round((ath.date - h.date) / (7*DAY_MS));
        const pl = plPrice((ath.date - GENESIS)/DAY_MS, a, b);
        const ratio = (ath.price / pl).toFixed(1);
        const active = i === 3;
        return `<tr>
            <td style="color:${COLORS[i]};font-weight:600">#${i+1}</td>
            <td>${h.date.toLocaleDateString('de-DE')}</td>
            <td>${ath.date.toLocaleDateString('de-DE')}</td>
            <td>${wks} W</td>
            <td>$${ath.price.toLocaleString('en-US')}</td>
            <td class="negative">${ath.drawdown}%</td>
            <td>${ratio}x</td>
            <td><span class="badge ${active?'badge-active':'badge-past'}">${active?'AKTIV':'Fertig'}</span></td>
        </tr>`;
    }).join('');
}

// === FETCH ALL DAILY DATA FROM BLOCKCHAIN.INFO (with localStorage cache) ===
const CACHE_KEY = 'btc_daily_data';
const CACHE_TS_KEY = 'btc_daily_ts';

function saveCacheData(data) {
    try {
        const compact = data.map(d => [d.days, d.price]);
        localStorage.setItem(CACHE_KEY, JSON.stringify(compact));
        localStorage.setItem(CACHE_TS_KEY, Date.now().toString());
    } catch(e) { /* localStorage voll oder nicht verfügbar */ }
}

function loadCacheData() {
    try {
        const raw = localStorage.getItem(CACHE_KEY);
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        return parsed.map(([days, price]) => ({
            days, price,
            date: new Date(GENESIS_MS + days * DAY_MS),
        }));
    } catch(e) { return null; }
}

async function fetchDailyData() {
    try {
        const r = await fetch('https://api.blockchain.info/charts/market-price?timespan=all&format=json&cors=true');
        if (!r.ok) throw new Error('API ' + r.status);
        const j = await r.json();
        const vals = j.values;
        const daily = [];
        for (const v of vals) {
            const days = Math.round((v.x - GENESIS.getTime() / 1000) / (DAY_MS / 1000));
            if (days > 0 && v.y > 0) {
                daily.push({ days, price: v.y, date: new Date(v.x * 1000) });
            }
        }
        saveCacheData(daily);
        return daily;
    } catch(e) {
        console.log('API nicht erreichbar, versuche localStorage-Cache...', e.message);
        const cached = loadCacheData();
        if (cached) {
            console.log(`${cached.length} Tagesdaten aus Cache geladen.`);
            return cached;
        }
        return null;
    }
}

// === BINANCE WEBSOCKET LIVE TICKER ===
let lastLivePrice = null;

function startLiveTicker() {
    try {
        const ws = new WebSocket('wss://stream.binance.com:9443/ws/btcusdt@trade');
        
        ws.onmessage = function(event) {
            const data = JSON.parse(event.data);
            const price = parseFloat(data.p);
            const prevPrice = lastLivePrice || price;
            const isFirst = !lastLivePrice;
            lastLivePrice = price;

            // On first live price, inject into DATA and update chart
            if (isFirst && DATA && DATA.length) {
                const now = new Date();
                const todayDays = Math.round((now - GENESIS) / DAY_MS);
                const last = DATA[DATA.length - 1];
                if (last.days === todayDays) {
                    last.price = price;
                    last.date = now;
                } else if (todayDays > last.days) {
                    DATA.push({ days: todayDays, price, date: now });
                }
                renderPL(false);
                updateStats();
            }

            // Activate live dot
            const dot = document.getElementById('live-dot');
            if (dot) { dot.style.background = 'var(--green)'; dot.classList.add('live-pulse'); }
            // Update header price
            const priceEl = document.getElementById('live-price');
            priceEl.textContent = '$' + price.toLocaleString('en-US', {maximumFractionDigits: 0});
            
            // Flash green/red on change
            if (price > prevPrice) {
                priceEl.style.color = 'var(--green)';
            } else if (price < prevPrice) {
                priceEl.style.color = 'var(--red)';
            }
            setTimeout(() => { priceEl.style.color = 'var(--text-primary)'; }, 300);
            
            // Update drawdown
            const ath = 126200;
            const dd = ((price - ath) / ath * 100);
            const ddEl = document.getElementById('stat-drawdown');
            if (ddEl) ddEl.textContent = dd.toFixed(1) + '%';
            
            // Update meta
            const metaEl = document.getElementById('live-meta');
            if (metaEl) {
                const now = new Date();
                metaEl.textContent = now.toLocaleTimeString('de-DE') + ' · Binance Live';
            }
        };
        
        ws.onerror = function() {
            console.log('Binance WebSocket nicht verfügbar, verwende Spot-Preis Fallback.');
            fetchSpotPrice();
        };
        
        ws.onclose = function() {
            // Reconnect after 5 seconds
            setTimeout(startLiveTicker, 5000);
        };
        
    } catch(e) {
        console.log('WebSocket nicht unterstützt, verwende Spot-Preis Fallback.');
        fetchSpotPrice();
    }
}

// Fallback: CoinGecko simple price (if WebSocket fails)
async function fetchSpotPrice() {
    try {
        const r = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd&include_24hr_change=true');
        if (!r.ok) return;
        const j = await r.json();
        const price = j.bitcoin.usd;
        const change24h = j.bitcoin.usd_24h_change;
        
        document.getElementById('live-price').textContent = '$' + price.toLocaleString('en-US', {maximumFractionDigits: 0});
        
        const ce = document.getElementById('live-change');
        ce.textContent = (change24h >= 0 ? '+' : '') + change24h.toFixed(2) + '% (24h)';
        ce.className = 'change ' + (change24h >= 0 ? 'positive' : 'negative');
        
        document.getElementById('live-meta').textContent = new Date().toLocaleTimeString('de-DE') + ' · CoinGecko Spot';
        
        // Update drawdown
        const ath = 126200;
        const dd = ((price - ath) / ath * 100);
        document.getElementById('stat-drawdown').textContent = dd.toFixed(1) + '%';
        
    } catch(e) {
        console.log('CoinGecko Spot auch nicht verfügbar.', e.message);
    }
}

async function init() {
    DATA = await fetchDailyData();
    if (!DATA || !DATA.length) {
        document.getElementById('live-meta').textContent = 'Keine Daten verfügbar – bitte Seite neu laden.';
        console.error('Keine Daten: API nicht erreichbar und kein Cache vorhanden.');
        return;
    }
    PL = fitPowerLaw(DATA);
    FLOOR = fitFloor(DATA, PL);

    const lastDay = DATA[DATA.length - 1];
    const lastDate = lastDay.date.toLocaleDateString('de-DE');
    const cachedTs = localStorage.getItem(CACHE_TS_KEY);
    const source = cachedTs && (Date.now() - parseInt(cachedTs)) > 60000 ? 'Cache' : 'Blockchain.info';
    console.log(`${DATA.length} Tagesdaten geladen (${source}, bis ${lastDate})`);
    document.getElementById('live-meta').textContent = lastDate + ' · ' + source + ' (täglich)';
    console.log(`Power Law: a=${PL.a.toFixed(4)}, b=${PL.b.toFixed(4)}, Floor: a=${FLOOR.a.toFixed(4)}, b=${FLOOR.b.toFixed(4)}`);

    renderPL();
    renderCycles();
    renderATHChart();
    updateStats();
    renderTable();

    // Start live price ticker
    startLiveTicker();

    // Periodically inject live price into DATA so chart stays current
    setInterval(() => {
        if (!lastLivePrice || !DATA || !DATA.length) return;
        const now = new Date();
        const todayDays = Math.round((now - GENESIS) / DAY_MS);
        const last = DATA[DATA.length - 1];
        if (last.days === todayDays) {
            // Update today's entry with live price
            last.price = lastLivePrice;
            last.date = now;
        } else if (todayDays > last.days) {
            // Append today as new data point
            DATA.push({ days: todayDays, price: lastLivePrice, date: now });
        }
        // Re-render chart without animation, and update stats
        renderPL(false);
        updateStats();
    }, 30000); // every 30 seconds

    // Resize canvas on window resize
    let resizeTimer;
    window.addEventListener('resize', () => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(() => renderPL(false), 150);
    });
}

init();
</script>
</body>
</html>
